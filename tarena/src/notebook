

					----------- 01.ts
集合  ： 数据存储 + 操作算法
	1） 用于存储 类型一致 的一组对象的数据结构
	2）类似于数组，但是集合提供了操作算法。

集合的用途:
	如：歌曲列表 联系人列表 对话记录 游戏英雄 装备 ...
	3) 集合比数组多了操作算法  便于提高编程效率
	
Collection 代表集合，定义了集合的公共方法
	|	add remove addAll removeAll
	|	contains size clear iterator ...
	|-- List 线性表，有先后次序（元素有位置）的集合
		|	在Collection基础上扩展出按位置操作方法
		|	 add(index,e) remove(index)
		|	 set(index,e) get(index)
		|-- ArrayList 实现了集合的方法
		|	使用"变长数组"算法实现的List
		|-- LinkedList
		|	使用"双向循环链表"实现的List
	|-- Set 数学集合：无序不重复
		|-- HashSet
		
Iterator 迭代器 :逐一(遍历，迭代)处理集合中的元素
	 1）Collection 定义了iterator() 方法用于创建Iterator接口实例。子类都实现了这个方法。
	*2） iterator接口一般都是用"内部类"实现的！
	i.getClass().getName()
	 3）Iterator API是给while()语句定制的！
	*4）迭代期间，不能使用集合方法添加或者删除元素
	 	迭代器提供了安全删除方法。

快速创建一个集合的方法：Collections.addAll(list,"a","b","c","d");
-------------------------- 排序 和 比较器 ---------------
1.对象是如何比较的
2.如何根据比较结果排序
3.如何定义"自定义的比较规则"？
4.自定义排序

目的：是理解如何使用比较结果影响排序结果

排序的算法不用变！Java中的 排序算法是：小到大升序排列。

利用comparator(比较器) 可以给定自定义的比较规则，
就可以实现自定义的排序。
	Comparator 中定义了方法compare(o1,o2)
   比较o1 o2两个对象 返回值：>0 =0 <0

利用的方法：
	Collections.sort(list,比较器)
就可以进行任意规则的排序
	
						------------- 02.ts
01:39:49   --------- 栈和队列 ---------------------

02：07：00 ------------ map接口 -------------------
hashcode() 和 equals()是一对，要么一起重写，要么一起不重写。
1.对象相等的时候，hashCode()的值一定一样；
2.对象不等的时候，hashCode()的值一般是不同的；
3.hashCode()是稳定不变的，即无论何时何地，"Tom"的hashCode()值都是84274。

1）数组的下表定位访问，性能非常好
2）根据key的hashCode()通过算法映射到数组下标的查找对象的方法。

散列表插入过程(put)：(也是hashcode和equals方法必须成对存在的原因)
	1）获得key的hashCode(),利用散列算法映射到
	散列表数组中"散列桶"的位置，遍历散列桶，使用
	key.equals()方法逐一比较key,确定位置，添加(替换)数据。
散列表查找过程(get)：
	2）根据key查找value(数据):获得key的hashCode(),
	利用散列算法映射到散列表数组中"散列桶"的位置，
	key.equals()方法逐一比较key,确定位置，获取
	这个位置的数据(value),如果没有数据，就返回null.

散列表的默认加载因子是75%。
加载因子 是 元素数量  和 散列表的容量的最大比值。
一旦实际容量的比值超过加载因子，散列表将扩容并重新散列，
减少重新散列次数将提高散列表性能。	